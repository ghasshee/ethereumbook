<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="smart_contracts_chapter">Smart Contracts and Solidity</h2>
<div class="sectionbody">
<div class="paragraph"><p>As we discussed in <a href="#intro_chapter">[intro_chapter]</a>, there are two different types of accounts in Ethereum: externally owned accounts (EOAs) and contract accounts. EOAs are controlled by users, often via software such as a wallet application that is external to the Ethereum platform. In contrast, contract accounts are controlled by program code (also commonly referred to as &#x201c;smart contracts&#x201d;) that is executed by the Ethereum Virtual Machine. In short, EOAs are simple accounts without any associated code or data storage, whereas contract accounts have both associated code and data storage. EOAs are controlled by transactions created and cryptographically signed with a private key in the "real world" external to and independent of the protocol, whereas contract accounts do not have private keys and so "control themselves" in the predetermined way prescribed by their smart contract code. Both types of accounts are identified by an Ethereum address. In this chapter, we will discuss contract accounts and the program code that controls them.</p></div>
<div class="sect2">
<h3 id="smart_contracts_definition">What Is a Smart Contract?</h3>
<div class="paragraph"><p>The term <em>smart contract</em> has been used over the years to describe a wide variety of different things. In the 1990s, cryptographer Nick Szabo coined the term and defined it as “a set of promises, specified in digital form, including protocols within which the parties perform on the other promises.” Since then, the concept of smart contracts has evolved, especially after the introduction of decentralized blockchain platforms with the invention of Bitcoin in 2009. In the context of Ethereum, the term is actually a bit of a misnomer, given that Ethereum smart contracts are neither smart nor legal contracts, but the term has stuck. In this book, we use the term “smart contracts” to refer to immutable computer programs that run deterministically in the context of an Ethereum Virtual Machine as part of the Ethereum network protocol&#x2014;i.e., on the decentralized Ethereum world computer.</p></div>
<div class="paragraph"><p>Let’s unpack that definition:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Computer programs
</dt>
<dd>
<p>
Smart contracts are simply computer programs. The word &#x201c;contract&#x201d; has no legal meaning in this context.
</p>
</dd>
<dt class="hdlist1">
Immutable
</dt>
<dd>
<p>
Once deployed, the code of a smart contract cannot change. Unlike with traditional software, the only way to modify a smart contract is to deploy a new instance.
</p>
</dd>
<dt class="hdlist1">
Deterministic
</dt>
<dd>
<p>
The outcome of the execution of a smart contract is the same for everyone who runs it, given the context of the transaction that initiated its execution and the state of the Ethereum blockchain at the moment of execution.
</p>
</dd>
<dt class="hdlist1">
EVM context
</dt>
<dd>
<p>
Smart contracts operate with a very limited execution context. They can access their own state, the context of the transaction that called them, and some information about the most recent blocks.
</p>
</dd>
<dt class="hdlist1">
Decentralized world computer
</dt>
<dd>
<p>
The EVM runs as a local instance on every Ethereum node, but because all instances of the EVM operate on the same initial state and produce the same final state, the system as a whole operates as a single "world computer."
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="smart_contract_lifecycle">Life Cycle of a Smart Contract</h3>
<div class="paragraph"><p>Smart contracts are typically written in a high-level language, such as Solidity. But in order to run, they must be compiled to the low-level bytecode that runs in the EVM. Once compiled, they are deployed on the Ethereum platform using a special <em>contract creation</em> transaction, which is identified as such by being sent to the special contract creation address, namely <code>0x0</code> (see <a href="#contract_reg">[contract_reg]</a>). Each contract is identified by an Ethereum address, which is derived from the contract creation transaction as a function of the originating account and nonce. The Ethereum address of a contract can be used in a transaction as the recipient, sending funds to the contract or calling one of the contract’s functions. Note that, unlike with EOAs, there are no keys associated with an account created for a new smart contract. As the contract creator, you don&#8217;t get any special privileges at the protocol level (although you can explicitly code them into the smart contract). You certainly don&#8217;t receive the private key for the contract account, which in fact does not exist&#x2014;we can say that smart contract accounts own themselves.</p></div>
<div class="paragraph"><p>Importantly, contracts <em>only run if they are called by a transaction</em>. All smart contracts in Ethereum are executed, ultimately, because of a transaction initiated from an EOA. A contract can call another contract that can call another contract, and so on, but the first contract in such a chain of execution will always have been called by a transaction from an EOA. Contracts never run “on their own” or “in the background.” Contracts effectively lie dormant until a transaction triggers execution, either directly or indirectly as part of a chain of contract calls. It is also worth noting that smart contracts are not executed "in parallel" in any sense&#x2014;the Ethereum world computer can be considered to be a single-threaded machine.</p></div>
<div class="paragraph"><p>Transactions are <em>atomic</em>, regardless of how many contracts they call or what those contracts do when called. Transactions execute in their entirety, with any changes in the global state (contracts, accounts, etc.) recorded only if all execution terminates successfully. Successful termination means that the program executed without an error and reached the end of execution. If execution fails due to an error, all of its effects (changes in state) are “rolled back” as if the transaction never ran. A failed transaction is still recorded as having been attempted, and the ether spent on gas for the execution is deducted from the originating account, but it otherwise has no other effects on contract or account state.</p></div>
<div class="paragraph"><p>As mentioned previously, it is important to remember that a contract’s code cannot be changed. However, a contract can be “deleted,” removing the code and its internal state (storage) from its address, leaving a blank account. Any transactions sent to that account address after the contract has been deleted do not result in any code execution, because there is no longer any code there to execute. To delete a contract, you execute an EVM opcode called <code>SELFDESTRUCT</code> (previously called <code>SUICIDE</code>). That operation costs “negative gas,” a gas refund, thereby incentivizing the release of network client resources from the deletion of stored state. Deleting a contract in this way does not remove the transaction history (past) of the contract, since the blockchain itself is immutable. It is also important to note that the <code>SELFDESTRUCT</code> capability will only be available if the contract author programmed the smart contract to have that functionality. If the contract&#8217;s code does not have a <code>SELFDESTRUCT</code> opcode, or it is inaccessible, the smart contract cannot be deleted.</p></div>
</div>
<div class="sect2">
<h3 id="high_level_languages">Introduction to Ethereum High-Level Languages</h3>
<div class="paragraph"><p>The EVM is a virtual machine that runs a special form of code called <em>EVM bytecode</em>, analogous to your computer&#8217;s CPU, which runs machine code such as x86_64. We will examine the operation and language of the EVM in much more detail in <a href="#evm_chapter">[evm_chapter]</a>. In this section we will look at how smart contracts are written to run on the EVM.</p></div>
<div class="paragraph"><p>While it is possible to program smart contracts directly in bytecode, EVM bytecode is rather unwieldy and very difficult for programmers to read and understand. Instead, most Ethereum developers use a high-level language to write programs, and a compiler to convert them into bytecode.</p></div>
<div class="paragraph"><p>While any high-level language could be adapted to write smart contracts, adapting an arbitrary language to be compilable to EVM bytecode is quite a cumbersome exercise and would in general lead to some amount of confusion. Smart contracts operate in a highly constrained and minimalistic execution environment (the EVM). In addition, a special set of EVM-specific system variables and functions needs to be available. As such, it is easier to build a smart contract language from scratch than it is to make a general-purpose language suitable for writing smart contracts. As a result, a number of special-purpose languages have emerged for programming smart contracts. Ethereum has several such languages, together with the compilers needed to produce EVM-executable bytecode.</p></div>
<div class="paragraph"><p>In general, programming languages can be classified into two broad programming paradigms: <em>declarative</em> and <em>imperative</em>, also known as <em>functional</em> and <em>procedural</em>, respectively. In declarative programming, we write functions that express the <em>logic</em> of a program, but not its <em>flow</em>. Declarative programming is used to create programs where there are no <em>side effects</em>, meaning that there are no changes to state outside of a function. Declarative programming languages include Haskell and SQL. Imperative programming, by contrast, is where a programmer writes a set of procedures that combine the logic and flow of a program. Imperative programming languages include C++ and Java. Some languages are “hybrid,” meaning that they encourage declarative programming but can also be used to express an imperative programming paradigm. Such hybrids include Lisp, JavaScript, and Python. In general, any imperative language can be used to write in a declarative paradigm, but it often results in inelegant code. By comparison, pure declarative languages cannot be used to write in an imperative paradigm. In purely declarative languages, <em>there are no “variables.”</em></p></div>
<div class="paragraph"><p>While imperative programming is more commonly used by programmers, it can be very difficult to write programs that execute <em>exactly as expected</em>. The ability of any part of the program to change the state of any other makes it difficult to reason about a program’s execution and introduces many opportunities for bugs. Declarative programming, by comparison, makes it easier to understand how a program will behave: since it has no side effects, any part of a program can be understood in isolation.</p></div>
<div class="paragraph"><p>In smart contracts, bugs literally cost money. As a result, it is critically important to write smart contracts without unintended effects. To do that, you must be able to clearly reason about the expected behavior of the program. So, declarative languages play a much bigger role in smart contracts than they do in general-purpose software. Nevertheless, as you will see, the most widely used language for smart contracts (Solidity) is imperative. Programmers, like most humans, resist change!</p></div>
<div class="paragraph"><p>Currently supported high-level programming languages for smart contracts include (ordered by approximate age):</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
LLL
</dt>
<dd>
<p>
A functional (declarative) programming language, with Lisp-like syntax. It was the first high-level language for Ethereum smart contracts but is rarely used today.
</p>
</dd>
<dt class="hdlist1">
Serpent
</dt>
<dd>
<p>
A procedural (imperative) programming language with a syntax similar to Python. Can also be used to write functional (declarative) code, though it is not entirely free of side effects.
</p>
</dd>
<dt class="hdlist1">
Solidity
</dt>
<dd>
<p>
A procedural (imperative) programming language with a syntax similar to JavaScript, C++, or Java. The most popular and frequently used language for Ethereum smart contracts.
</p>
</dd>
<dt class="hdlist1">
Vyper
</dt>
<dd>
<p>
A more recently developed language, similar to Serpent and again with Python-like syntax. Intended to get closer to a pure-functional Python-like language than Serpent, but not to replace Serpent.
</p>
</dd>
<dt class="hdlist1">
Bamboo
</dt>
<dd>
<p>
A newly developed language, influenced by Erlang, with explicit state transitions and without iterative flows (loops). Intended to reduce side effects and increase auditability. Very new and yet to be widely adopted.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>As you can see, there are many languages to choose from. However, of all of these Solidity is by far the most popular, to the point of being the <em>de facto</em> high-level language of Ethereum and even other EVM-like blockchains. We will spend most of our time using Solidity, but will also explore some of the examples in other high-level languages to gain an understanding of their different philosophies.</p></div>
</div>
<div class="sect2">
<h3 id="building_a_smart_contract_sec">Building a Smart Contract with Solidity</h3>
<div class="paragraph"><p>Solidity was created by Gavin Wood (coauthor of this book) as a language explicitly for writing smart contracts with features to directly support execution in the decentralized environment of the Ethereum world computer. The resulting attributes are quite general, and so it has ended up being used for coding smart contracts on several other blockchain platforms. It was developed by Christian Reitiwessner and then also by Alex Beregszaszi, Liana Husikyan, Yoichi Hirai, and several former Ethereum core contributors. Solidity is now developed and maintained as an independent project <a href="https://github.com/ethereum/solidity">on GitHub</a>.</p></div>
<div class="paragraph"><p>The main "product" of the Solidity project is the Solidity compiler, <code>solc</code>, which converts programs written in the Solidity language to EVM bytecode. The project also manages the important application binary interface (ABI) standard for Ethereum smart contracts, which we will explore in detail in this chapter. Each version of the Solidity compiler corresponds to and compiles a specific version of the Solidity language.</p></div>
<div class="paragraph"><p>To get started, we will download a binary executable of the Solidity compiler. Then we will develop and compile a simple contract, following on from the example we started with in <a href="#intro_chapter">[intro_chapter]</a>.</p></div>
<div class="sect3">
<h4 id="_selecting_a_version_of_solidity">Selecting a Version of Solidity</h4>
<div class="paragraph"><p>Solidity follows a versioning model called <a href="https://semver.org/"><em>semantic versioning</em></a>, which specifies version numbers structured as three numbers separated by dots: <em><code>MAJOR.MINOR.PATCH</code></em>. The "major" number is incremented for major and <em>backward-incompatible</em> changes, the "minor" number is incremented as backward-compatible features are added in between major releases, and the "patch" number is incremented for backward-compatible bug fixes.</p></div>
<div class="paragraph"><p>At the time of writing, Solidity is at version 0.4.24.  The rules for major version 0, which is for initial development of a project, are different: anything may change at any time. In practice, Solidity treats the "minor" number as if it were the major version and the "patch" number as if it were the minor version. Therefore, in 0.4.24, 4 is considered to be the major version and 24 the minor version.</p></div>
<div class="paragraph"><p>The 0.5 major version release of Solidity is anticipated imminently.</p></div>
<div class="paragraph"><p>As you saw in <a href="#intro_chapter">[intro_chapter]</a>, your Solidity programs can contain a pragma directive that specifies the minimum and maximum versions of Solidity that it is compatible with, and can be used to compile your contract.</p></div>
<div class="paragraph"><p>Since Solidity is rapidly evolving, it is often better to install the latest release.</p></div>
</div>
<div class="sect3">
<h4 id="_download_and_install">Download and Install</h4>
<div class="paragraph"><p>There are a number of methods you can use to download and install Solidity, either as a binary release or by compiling from source code. You can find detailed instructions in <a href="http://bit.ly/2RrZmup">the Solidity documentation</a>.</p></div>
<div class="paragraph"><p>Here&#8217;s how to install the latest binary release of Solidity on an Ubuntu/Debian operating system, using the <code>apt</code> package manager:</p></div>
<pre data-type="programlisting">
$ <strong>sudo add-apt-repository ppa:ethereum/ethereum</strong>
$ <strong>sudo apt update</strong>
$ <strong>sudo apt install solc</strong>
</pre>
<div class="paragraph"><p>Once you have <code>solc</code> installed, check the version by running:</p></div>
<pre data-type="programlisting">
$ <strong>solc --version</strong>
solc, the solidity compiler commandline interface
Version: 0.4.24+commit.e67f0147.Linux.g++
</pre>
<div class="paragraph"><p>There are a number of other ways to install Solidity, depending on your operating system and requirements, including compiling from the source code directly. For more information see <a href="https://github.com/ethereum/solidity">https://github.com/ethereum/solidity</a>.</p></div>
</div>
<div class="sect3">
<h4 id="_development_environment">Development Environment</h4>
<div class="paragraph"><p>To develop in Solidity, you can use any text editor and <code>solc</code> on the command line. However, you might find that some text editors designed for development, such as Emacs, Vim, and Atom, offer additional features such as syntax highlighting and macros that make Solidity development easier.</p></div>
<div class="paragraph"><p>There are also web-based development environments, such as <a href="https://remix.ethereum.org/">Remix IDE</a> and <a href="https://ethfiddle.com/">EthFiddle</a>.</p></div>
<div class="paragraph"><p>Use the tools that make you productive. In the end, Solidity programs are just plain text files. While fancy editors and development environments can make things easier, you don&#8217;t need anything more than a simple text editor, such as nano (Linux/Unix), TextEdit (macOS), or even NotePad (Windows). Simply save your program source code with a <em>.sol</em> extension and it will be recognized by the Solidity compiler as a Solidity program.</p></div>
</div>
<div class="sect3">
<h4 id="_writing_a_simple_solidity_program">Writing a Simple Solidity Program</h4>
<div class="paragraph"><p>In <a href="#intro_chapter">[intro_chapter]</a>, we wrote our first Solidity program.  When we first built the <code>Faucet</code> contract, we used the Remix IDE to compile and deploy the contract. In this section, we will revisit, improve, and embellish <code>Faucet</code>.</p></div>
<div class="paragraph"><p>Our first attempt looked like <a href="#original_sol_faucet">[original_sol_faucet]</a>.</p></div>
<div class="exampleblock" id="original_sol_faucet">
<div class="title">Example 1. Faucet.sol: A Solidity contract implementing a faucet</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
</div>
<div class="sect3">
<h4 id="_compiling_with_the_solidity_compiler_solc">Compiling with the Solidity Compiler (solc)</h4>
<div class="paragraph"><p>Now, we will use the Solidity compiler on the command line to compile our contract directly. The Solidity compiler <code>solc</code> offers a variety of options, which you can see by passing the <code>--help</code> argument.</p></div>
<div class="paragraph"><p>We use the <code>--bin</code> and <code>--optimize</code> arguments of <code>solc</code> to produce an optimized binary of our example contract:</p></div>
<pre data-type="programlisting">
$ <strong>solc --optimize --bin Faucet.sol</strong>
======= Faucet.sol:Faucet =======
Binary:
6060604052341561000f57600080fd5b60cf8061001d6000396000f300606060405260043610603e5
763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416
632e1a7d4d81146040575b005b3415604a57600080fd5b603e60043567016345785d8a00008111156
06357600080fd5b73ffffffffffffffffffffffffffffffffffffffff331681156108fc0282604051
600060405180830381858888f19350505050151560a057600080fd5b505600a165627a7a723058203
556d79355f2da19e773a9551e95f1ca7457f2b5fbbf4eacf7748ab59d2532130029
</pre>
<div class="paragraph"><p>The result that <code>solc</code> produces is a hex-serialized binary that can be submitted to the Ethereum blockchain.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="eth_contract_abi_sec">The Ethereum Contract ABI</h3>
<div class="paragraph"><p>In computer software, an <em>application binary interface</em> is an interface between two program modules; often, between the operating system and user programs. An ABI defines how data structures and functions are accessed in <em>machine code</em>; this is not to be confused with an API, which defines this access in high-level, often human-readable formats as <em>source code</em>. The ABI is thus the primary way of encoding and decoding data into and out of machine code.</p></div>
<div class="paragraph"><p>In Ethereum, the ABI is used to encode contract calls for the EVM and to read data out of transactions. The purpose of an ABI is to define the functions in the contract that can be invoked and describe how each function will accept arguments and return its result.</p></div>
<div class="paragraph"><p>A contract&#8217;s ABI is specified as a JSON array of function descriptions (see <a href="#solidity_functions">[solidity_functions]</a>) and events (see <a href="#solidity_events">[solidity_events]</a>). A function description is a JSON object with fields <code>type</code>, <code>name</code>, <code>inputs</code>, <code>outputs</code>, <code>constant</code>, and <code>payable</code>. An event description object has fields <code>type</code>, <code>name</code>, <code>inputs</code>, and <code>anonymous</code>.</p></div>
<div class="paragraph"><p>We use the <code>solc</code> command-line Solidity compiler to produce the ABI for our <em>Faucet.sol</em> example contract:</p></div>
<pre data-type="programlisting">
$ <strong>solc --abi Faucet.sol</strong>
======= Faucet.sol:Faucet =======
Contract JSON ABI
[{"constant":false,"inputs":[{"name":"withdraw_amount","type":"uint256"}], \
"name":"withdraw","outputs":[],"payable":false,"stateMutability":"nonpayable", \
"type":"function"},{"payable":true,"stateMutability":"payable", \
"type":"fallback"}]
</pre>
<div class="paragraph"><p>As you can see, the compiler produces a JSON array describing the two functions that are defined by <em>Faucet.sol</em>. This JSON can be used by any application that wants to access the <code>Faucet</code> contract once it is deployed. Using the ABI, an application such as a wallet or DApp browser can construct transactions that call the functions in <code>Faucet</code> with the correct arguments and argument types. For example, a wallet would know that to call the function <code>withdraw</code> it would have to provide a <code>uint256</code> argument named <code>withdraw_amount</code>. The wallet could prompt the user to provide that value, then create a transaction that encodes it and executes the <code>withdraw</code> function.</p></div>
<div class="paragraph"><p>All that is needed for an application to interact with a contract is an ABI and the address where the contract has been deployed.</p></div>
<div class="sect3">
<h4 id="solidity_pragma">Selecting a Solidity Compiler and Language Version</h4>
<div class="paragraph"><p>As we saw in the previous code, our <code>Faucet</code> contract compiles successfully with Solidity version 0.4.21. But what if we had used a different version of the Solidity compiler? The language is still in constant flux and things may change in unexpected ways. Our contract is fairly simple, but what if our program used a feature that was only added in Solidity version 0.4.19 and we tried to compile it with 0.4.18?</p></div>
<div class="paragraph"><p>To resolve such issues, Solidity offers a <em>compiler directive</em> known as a <em>version pragma</em> that instructs the compiler that the program expects a specific compiler (and language) version. Let’s look at an example:</p></div>
<div class="listingblock" id="compiler_version">
<div class="content">
<pre><code>pragma solidity ^0.4.19;</code></pre>
</div></div>
<div class="paragraph"><p>The Solidity compiler reads the version pragma and will produce an error if the compiler version is incompatible with the version pragma. In this case, our version pragma says that this program can be compiled by a Solidity compiler with a minimum version of 0.4.19. The symbol <code>^</code> states, however, that we allow compilation with any <em>minor revision</em> above 0.4.19; e.g., 0.4.20, but not 0.5.0 (which is a major revision, not a minor revision). Pragma directives are not compiled into EVM bytecode. They are only used by the compiler to check compatibility.</p></div>
<div class="paragraph"><p>Let’s add a pragma directive to our <code>Faucet</code> contract. We will name the new file <em>Faucet2.sol</em>, to keep track of our changes as we proceed through these examples starting in <a href="#add_pragma_to_faucet">[add_pragma_to_faucet]</a>.</p></div>
<div class="exampleblock" id="add_pragma_to_faucet">
<div class="title">Example 2. Faucet2.sol: Adding the version pragma to Faucet</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Adding a version pragma is a best practice, as it avoids problems with mismatched compiler and language versions. We will explore other best practices and continue to improve the <code>Faucet</code> contract throughout this chapter.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_programming_with_solidity">Programming with Solidity</h3>
<div class="paragraph"><p>In this section, we will look at some of the capabilities of the Solidity language. As we mentioned in <a href="#intro_chapter">[intro_chapter]</a>, our first contract example was very simple and also flawed in various ways. We&#8217;ll gradually improve it here, while exploring how to use Solidity. This won&#8217;t be a comprehensive Solidity tutorial, however, as Solidity is quite complex and rapidly evolving. We&#8217;ll cover the basics and give you enough of a foundation to be able to explore the rest on your own. The documentation for Solidity can be found
<a href="https://solidity.readthedocs.io/en/latest/">on the project website</a>.</p></div>
<div class="sect3">
<h4 id="_data_types">Data Types</h4>
<div class="paragraph"><p>First, let&#8217;s look at some of the basic data types offered in Solidity:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Boolean (<code>bool</code>)
</dt>
<dd>
<p>
Boolean value, <code>true</code> or <code>false</code>, with logical operators <code>!</code> (not), <code>&amp;&amp;</code> (and), <code>||</code> (or), <code>==</code> (equal), and <code>!=</code> (not equal).
</p>
</dd>
<dt class="hdlist1">
Integer (<code>int</code>, <code>uint</code>)
</dt>
<dd>
<p>
Signed (<code>int</code>) and unsigned (<code>uint</code>) integers, declared in increments of 8 bits from <code>int8</code> to <code>uint256</code>. Without a size suffix, 256-bit quantities are used, to match the word size of the EVM.
</p>
</dd>
<dt class="hdlist1">
Fixed point (<code>fixed</code>, <code>ufixed</code>)
</dt>
<dd>
<p>
Fixed-point numbers, declared with (<code>u</code>)<code>fixed<em>M</em>x<em>N</em></code> where <em><code>M</code></em> is the size in bits (increments of 8 up to 256) and <em><code>N</code></em> is the number of decimals after the point (up to 18); e.g., <code>ufixed32x2</code>.
</p>
</dd>
<dt class="hdlist1">
Address
</dt>
<dd>
<p>
A 20-byte Ethereum address. The <code>address</code> object has many helpful member functions, the main ones being <code>balance</code> (returns the account balance) and <span class="keep-together"><code>transfer</code></span> (transfers ether to the account).
</p>
</dd>
<dt class="hdlist1">
Byte array (fixed)
</dt>
<dd>
<p>
Fixed-size arrays of bytes, declared with <code>bytes1</code> up to <code>bytes32</code>.
</p>
</dd>
<dt class="hdlist1">
Byte array (dynamic)
</dt>
<dd>
<p>
Variable-sized arrays of bytes, declared with <code>bytes</code> or <code>string</code>.
</p>
</dd>
<dt class="hdlist1">
Enum
</dt>
<dd>
<p>
User-defined type for enumerating discrete values: <code>enum NAME {LABEL1, LABEL 2, ...}</code>.
</p>
</dd>
<dt class="hdlist1">
Arrays
</dt>
<dd>
<p>
An array of any type, either fixed or dynamic: <code>uint32[][5]</code> is a fixed-size array of five dynamic arrays of unsigned integers.
</p>
</dd>
<dt class="hdlist1">
Struct
</dt>
<dd>
<p>
User-defined data containers for grouping variables: <code>struct NAME {TYPE1 <span class="keep-together">VARIABLE1</span>; TYPE2 VARIABLE2; ...}</code>.
</p>
</dd>
<dt class="hdlist1">
Mapping
</dt>
<dd>
<p>
Hash lookup tables for <em><code>key</code></em> <code>&#8658;</code> <em><code>value</code></em> pairs: <code>mapping(KEY_TYPE &#8658; VALUE_TYPE) NAME</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>In addition to these data types, Solidity also offers a variety of value literals that can be used to calculate different units:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Time units
</dt>
<dd>
<p>
The units <code>seconds</code>, <code>minutes</code>, <code>hours</code>, and <code>days</code> can be used as suffixes, converting to multiples of the base unit <code>seconds</code>.
</p>
</dd>
<dt class="hdlist1">
Ether units
</dt>
<dd>
<p>
The units <code>wei</code>, <code>finney</code>, <code>szabo</code>, and <code>ether</code> can be used as suffixes, converting to multiples of the base unit <code>wei</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>In our <code>Faucet</code> contract example, we used a <code>uint</code> (which is an alias for <code>uint256</code>) for the <code>withdraw_amount</code> variable. We also indirectly used an <code>address</code> variable, which we set with <code>msg.sender</code>. We will use more of these data types in our examples in the rest of this chapter.</p></div>
<div class="paragraph"><p>Let&#8217;s use one of the unit multipliers to improve the readability of our example contract. In the <code>withdraw</code> function we limit the maximum withdrawal, expressing the limit in wei, the base unit of ether:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>require(withdraw_amount &lt;= 100000000000000000);</code></pre>
</div></div>
<div class="paragraph"><p>That&#8217;s not very easy to read. We can improve our code by using the unit multiplier <code>ether</code>, to express the value in ether instead of wei:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>require(withdraw_amount &lt;= 0.1 ether);</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_predefined_global_variables_and_functions">Predefined Global Variables and Functions</h4>
<div class="paragraph"><p>When a contract is executed in the EVM, it has access to a small set of global objects. These include the <code>block</code>, <code>msg</code>, and <code>tx</code> objects. In addition, Solidity exposes a number of EVM opcodes as predefined functions. In this section we will examine the variables and functions you can access from within a smart contract in Solidity.</p></div>
<div class="sect4">
<h5 id="_transaction_message_call_context">Transaction/message call context</h5>
<div class="paragraph"><p>The <code>msg</code> object is the transaction call (EOA originated) or message call (contract originated) that launched this contract execution. It contains a number of useful attributes:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>msg.sender</code>
</dt>
<dd>
<p>
We&#8217;ve already used this one. It represents the address that initiated this contract call, not necessarily the originating EOA that sent the transaction. If our contract was called directly by an EOA transaction, then this is the address that signed the transaction, but otherwise it will be a contract address.
</p>
</dd>
<dt class="hdlist1">
<code>msg.value</code>
</dt>
<dd>
<p>
The value of ether sent with this call (in wei).
</p>
</dd>
<dt class="hdlist1">
<code>msg.gas</code>
</dt>
<dd>
<p>
The amount of gas left in the gas supply of this execution environment. This was deprecated in Solidity v0.4.21 and replaced by the <code>gasleft</code> function.
</p>
</dd>
<dt class="hdlist1">
<code>msg.data</code>
</dt>
<dd>
<p>
The data payload of this call into our contract.
</p>
</dd>
<dt class="hdlist1">
<code>msg.sig</code>
</dt>
<dd>
<p>
The first four bytes of the data payload, which is the function selector.
</p>
</dd>
</dl></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>Whenever a contract calls another contract, the values of all the attributes of <code>msg</code> change to reflect the new caller&#8217;s information. The only exception to this is the <code>delegatecall</code> function, which runs the code of another contract/library within the original <code>msg</code> context.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect4">
<h5 id="_transaction_context">Transaction context</h5>
<div class="paragraph"><p>The <code>tx</code> object provides a means of accessing transaction-related information:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>tx.gasprice</code>
</dt>
<dd>
<p>
The gas price in the calling transaction.
</p>
</dd>
<dt class="hdlist1">
<code>tx.origin</code>
</dt>
<dd>
<p>
The address of the originating EOA for this transaction. WARNING: unsafe!
</p>
</dd>
</dl></div>
</div>
<div class="sect4">
<h5 id="_block_context">Block context</h5>
<div class="paragraph"><p>The <code>block</code> object contains information about the current block:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>block.blockhash(<em>blockNumber</em>)</code>
</dt>
<dd>
<p>
The block hash of the specified block number, up to 256 blocks in the past. Deprecated and replaced with the <code>blockhash</code> function in Solidity v0.4.22.
</p>
</dd>
<dt class="hdlist1">
<code>block.coinbase</code>
</dt>
<dd>
<p>
The address of the recipient of the current block&#8217;s fees and block reward.
</p>
</dd>
<dt class="hdlist1">
<code>block.difficulty</code>
</dt>
<dd>
<p>
The difficulty (proof of work) of the current block.
</p>
</dd>
<dt class="hdlist1">
<code>block.gaslimit</code>
</dt>
<dd>
<p>
The maximum amount of gas that can be spent across all transactions included in the current block.
</p>
</dd>
<dt class="hdlist1">
<code>block.number</code>
</dt>
<dd>
<p>
The current block number (blockchain height).
</p>
</dd>
<dt class="hdlist1">
<code>block.timestamp</code>
</dt>
<dd>
<p>
The timestamp placed in the current block by the miner (number of seconds since the Unix epoch).
</p>
</dd>
</dl></div>
</div>
<div class="sect4">
<h5 id="solidity_address_object">address object</h5>
<div class="paragraph"><p>Any address, either passed as an input or cast from a contract object, has a number of attributes and methods:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>address.balance</code>
</dt>
<dd>
<p>
The balance of the address, in wei. For example, the current contract balance is <code>address(this).balance</code>.
</p>
</dd>
<dt class="hdlist1">
<code>address.transfer(<em>amount</em>)</code>
</dt>
<dd>
<p>
Transfers the amount (in wei) to this address, throwing an exception on any error. We used this function in our <code>Faucet</code> example as a method on the <code>msg.sender</code> address, as <code>msg.sender.transfer</code>.
</p>
</dd>
<dt class="hdlist1">
<code>address.send(<em>amount</em>)</code>
</dt>
<dd>
<p>
Similar to <code>transfer</code>, only instead of throwing an exception, it returns <code>false</code> on error. WARNING: always check the return value of <code>send</code>.
</p>
</dd>
<dt class="hdlist1">
<code>address.call(<em>payload</em>)</code>
</dt>
<dd>
<p>
Low-level <code>CALL</code> function&#x2014;can construct an arbitrary message call with a data payload. Returns <code>false</code> on error. WARNING: unsafe&#x2014;recipient can (accidentally or maliciously) use up all your gas, causing your contract to halt with an <code>OOG</code> exception; always check the return value of <code>call</code>.
</p>
</dd>
<dt class="hdlist1">
<code>address.callcode(<em>payload</em>)</code>
</dt>
<dd>
<p>
Low-level <code>CALLCODE</code> function, like <code>address(this).call(...)</code> but with this contract&#8217;s code replaced with that of <code>address</code>. Returns <code>false</code> on error. WARNING: advanced use only!
</p>
</dd>
<dt class="hdlist1">
<code>address.delegatecall()</code>
</dt>
<dd>
<p>
Low-level <code>DELEGATECALL</code> function, like <code>callcode(...)</code> but with the full <code>msg</code> context seen by the current contract. Returns <code>false</code> on error. WARNING: advanced use only!
</p>
</dd>
</dl></div>
</div>
<div class="sect4">
<h5 id="_built_in_functions">Built-in functions</h5>
<div class="paragraph"><p>Other functions worth noting are:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>addmod</code>, <code>mulmod</code>
</dt>
<dd>
<p>
For modulo addition and multiplication. For example, <code>addmod(x,y,k)</code> calculates <code>(x + y) % k</code>.
</p>
</dd>
<dt class="hdlist1">
<code>keccak256</code>, <code>sha256</code>, <code>sha3</code>, <code>ripemd160</code>
</dt>
<dd>
<p>
Functions to calculate hashes with various standard hash algorithms.
</p>
</dd>
<dt class="hdlist1">
<code>ecrecover</code>
</dt>
<dd>
<p>
Recovers the address used to sign a message from the signature.
</p>
</dd>
<dt class="hdlist1">
<code>selfdestrunct(<em>recipient_address</em>)</code>
</dt>
<dd>
<p>
Deletes the current contract, sending any remaining ether in the account to the recipient address.
</p>
</dd>
<dt class="hdlist1">
<code>this</code>
</dt>
<dd>
<p>
The address of the currently executing contract account.
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect3">
<h4 id="_contract_definition">Contract Definition</h4>
<div class="paragraph"><p>Solidity&#8217;s principal data type is <code>contract</code>; our <code>Faucet</code> example simply defines a <span class="keep-together"><code>contract</code></span> object. Similar to any object in an object-oriented language, the contract is a container that includes data and methods.</p></div>
<div class="paragraph"><p>Solidity offers two other object types that are similar to a contract:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>interface</code>
</dt>
<dd>
<p>
An interface definition is structured exactly like a contract, except none of the functions are defined, they are only declared. This type of declaration is often called a <em>stub</em>; it tells you the functions' arguments and return types without any implementation. An interface specifies the "shape" of a contract; when inherited, each of the functions declared by the interface must be defined by the child.
</p>
</dd>
<dt class="hdlist1">
<code>library</code>
</dt>
<dd>
<p>
A library contract is one that is meant to be deployed only once and used by other contracts, using the <code>delegatecall</code> method (see <a href="#solidity_address_object">[solidity_address_object]</a>).
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="solidity_functions">Functions</h4>
<div class="paragraph"><p>Within a contract, we define functions that can be called by an EOA transaction or another contract. In our <code>Faucet</code> example, we have two functions: <code>withdraw</code> and the (unnamed) <em>fallback</em> function.</p></div>
<div class="paragraph"><p>The syntax we use to declare a function in Solidity is as follows:</p></div>
<pre data-type="programlisting">
function FunctionName([<em>parameters</em>]) {public|private|internal|external}
[pure|constant|view|payable] [<em>modifiers</em>] [returns (<em>return types</em>)]
</pre>
<div class="paragraph"><p>Let&#8217;s look at each of these components:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>FunctionName</code>
</dt>
<dd>
<p>
The name of the function, which is used to call the function in a transaction (from an EOA), from another contract, or even from within the same contract. One function in each contract may be defined without a name, in which case it is the <em>fallback</em> function, which is called when no other function is named. The fallback function cannot have any arguments or return anything.
</p>
</dd>
<dt class="hdlist1">
<em><code>parameters</code></em>
</dt>
<dd>
<p>
Following the name, we specify the arguments that must be passed to the function, with their names and types. In our <code>Faucet</code> example we defined <code>uint withdraw_amount</code> as the only argument to the <code><span class="keep-together">withdraw</span></code> function.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The next set of keywords (<code>public</code>, <code>private</code>, <code>internal</code>, <code>external</code>) specify the function&#8217;s <em>visibility</em>:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>public</code>
</dt>
<dd>
<p>
Public is the default; such functions can be called by other contracts or EOA transactions, or from within the contract. In our <code>Faucet</code> example, both functions are defined as public.
</p>
</dd>
<dt class="hdlist1">
<code>external</code>
</dt>
<dd>
<p>
External functions are like public functions, except they cannot be called from within the contract unless explicitly prefixed with the keyword <code>this</code>.
</p>
</dd>
<dt class="hdlist1">
<code>internal</code>
</dt>
<dd>
<p>
Internal functions are only accessible from within the contract&#x2014;they cannot be called by another contract or EOA transaction. They can be called by derived contracts (those that inherit this one).
</p>
</dd>
<dt class="hdlist1">
<code>private</code>
</dt>
<dd>
<p>
Private functions are like internal functions but cannot be called by derived contracts.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Keep in mind that the terms <em>internal</em> and <em>private</em> are somewhat misleading. Any function or data inside a contract is always <em>visible</em> on the public blockchain, meaning that anyone can see the code or data. The keywords described here only affect how and when a function can be <em>called</em>.</p></div>
<div class="paragraph"><p>The second set of keywords (<code>pure</code>, <code>constant</code>, <code>view</code>, <code>payable</code>) affect the behavior of the function:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>constant</code> or <code>view</code>
</dt>
<dd>
<p>
A function marked as a <em>view</em> promises not to modify any state. The term <em>constant</em> is an alias for view that will be deprecated in a future release. At this time, the compiler does not enforce the <code>view</code> modifier, only producing a warning, but this is expected to become an enforced keyword in v0.5 of Solidity.
</p>
</dd>
<dt class="hdlist1">
<code>pure</code>
</dt>
<dd>
<p>
A pure function is one that neither reads nor writes any variables in storage. It can only operate on arguments and return data, without reference to any stored data. Pure functions are intended to encourage declarative-style programming without side effects or state.
</p>
</dd>
<dt class="hdlist1">
<code>payable</code>
</dt>
<dd>
<p>
A payable function is one that can accept incoming payments. Functions not declared as <code>payable</code> will reject incoming payments. There are two exceptions, due to design decisions in the EVM: coinbase payments and <code>SELFDESTRUCT</code> inheritance will be paid even if the fallback function is not declared as <code>payable</code>, but this makes sense because code execution is not part of those payments anyway.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>As you can see in our <code>Faucet</code> example, we have one payable function (the fallback function), which is the only function that can receive incoming payments.</p></div>
</div>
<div class="sect3">
<h4 id="_contract_constructor_and_selfdestruct">Contract Constructor and selfdestruct</h4>
<div class="paragraph"><p>There is a special function that is only used once. When a contract is created, it also runs the <em>constructor function</em> if one exists, to initialize the state of the contract. The constructor is run in the same transaction as the contract creation. The constructor function is optional; you&#8217;ll notice our <code>Faucet</code> example doesn&#8217;t have one.</p></div>
<div class="paragraph"><p>Constructors can be specified in two ways. Up to and including in Solidity v0.4.21, the constructor is a function whose name matches the name of the contract, as you can see here:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The difficulty with this format is that if the contract name is changed and the constructor function name is not changed, it is no longer a constructor. Likewise, if there is an accidental typo in the naming of the contract and/or constructor, the function is again no longer a constructor. This can cause some pretty nasty, unexpected, and difficult-to-find bugs. Imagine for example if the constructor is setting the owner of the contract for purposes of control. If the function is not actually the constructor because of a naming error, not only will the owner be left unset at the time of contract creation, but the function may also be deployed as a permanent and "callable" part of the contract, like a normal function, allowing any third party to hijack the contract and become the "owner" after contract creation.</p></div>
<div class="paragraph"><p>To address the potential problems with constructor functions being based on having an identical name as the contract, Solidity v0.4.22 introduces a <code>constructor</code> keyword that operates like a constructor function but does not have a name. Renaming the contract does not affect the constructor at all. Also, it is easier to identify which function is the constructor. It looks like this:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>To summarize, a contract&#8217;s life cycle starts with a creation transaction from an EOA or contract account. If there is a constructor, it is executed as part of contract creation, to initialize the state of the contract as it is being created, and is then discarded.</p></div>
<div class="paragraph"><p>The other end of the contract&#8217;s life cycle is <em>contract destruction</em>. Contracts are destroyed by a special EVM opcode called <code>SELFDESTRUCT</code>. It used to be called <span class="keep-together"><code>SUICIDE</code></span>, but that name was deprecated due to the negative associations of the word. In Solidity, this opcode is exposed as a high-level built-in function called <code>selfdestruct</code>, which takes one argument: the address to receive any ether balance remaining in the contract account. It looks like this:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Note that you must explicitly add this command to your contract if you want it to be deletable&#x2014;this is the only way a contract can be deleted, and it is not present by default. In this way, users of a contract who might rely on a contract being there forever can be certain that a contract can&#8217;t be deleted if it doesn&#8217;t contain a <span class="keep-together"><code>SELFDESTRUCT</code></span> opcode.</p></div>
</div>
<div class="sect3">
<h4 id="_adding_a_constructor_and_selfdestruct_to_our_faucet_example">Adding a Constructor and selfdestruct to Our Faucet Example</h4>
<div class="paragraph"><p>The <code>Faucet</code> example contract we introduced in <a href="#intro_chapter">[intro_chapter]</a> does not have any constructor or <code>selfdestruct</code> functions. It is an eternal contract that cannot be deleted. Let&#8217;s change that, by adding a constructor and <code>selfdestruct</code> function. We probably want <code>selfdestruct</code> to be callable <em>only</em> by the EOA that originally created the contract. By convention, this is usually stored in an address variable called <code>owner</code>. Our constructor sets the <code>owner</code> variable, and the <code>selfdestruct</code> function will first check that the owner called it directly.</p></div>
<div class="paragraph"><p>First, our constructor:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>We&#8217;ve changed the pragma directive to specify v0.4.22 as the minimum version for this example, as we are using the new <code>constructor</code> keyword introduced in v0.4.22 of Solidity. Our contract now has an <code>address</code> type variable named <code>owner</code>. The name "owner" is not special in any way. We could call this address variable "potato" and still use it the same way. The name <code>owner</code> simply makes its purpose clear.</p></div>
<div class="paragraph"><p>Next, our constructor, which runs as part of the contract creation transaction, assigns the address from <code>msg.sender</code> to the <code>owner</code> variable. We used <code>msg.sender</code> in the <span class="keep-together"><code>withdraw</code></span> function to identify the initiator of the withdrawal request. In the constructor, however, the <code>msg.sender</code> is the EOA or contract address that initiated contract creation. We know this is the case <em>because</em> this is a constructor function: it only runs once, during contract creation.</p></div>
<div class="paragraph"><p>Now we can add a function to destroy the contract. We need to make sure that only the owner can run this function, so we will use a <code>require</code> statement to control access. Here&#8217;s how it will look:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>If anyone calls this <code>destroy</code> function from an address other than <code>owner</code>, it will fail. But if the same address stored in <code>owner</code> by the constructor calls it, the contract will self-destruct and send any remaining balance to the <code>owner</code> address. Note that we did not use the unsafe <code>tx.origin</code> to determine whether the owner wished to destroy the contract&#x2014;using <code>tx.orgin</code> would allow malign contracts to destroy your contract without your permission.</p></div>
</div>
<div class="sect3">
<h4 id="_function_modifiers">Function Modifiers</h4>
<div class="paragraph"><p>Solidity offers a special type of function called a <em>function modifier</em>. You apply modifiers to functions by adding the modifier name in the function declaration. Modifiers are most often used to create conditions that apply to many functions within a contract. We have an access control statement already, in our <code>destroy</code> function. Let&#8217;s create a function modifier that expresses that condition:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>This function modifier, named <code>onlyOwner</code>, sets a condition on any function that it modifies, requiring that the address stored as the <code>owner</code> of the contract is the same as the address of the transaction&#8217;s <code>msg.sender</code>. This is the basic design pattern for access control, allowing only the owner of a contract to execute any function that has the <code>onlyOwner</code> modifier.</p></div>
<div class="paragraph"><p>You may have noticed that our function modifier has a peculiar syntactic "placeholder" in it, an underscore followed by a semicolon (<code>&#95;;</code>). This placeholder is replaced by the code of the function that is being modified. Essentially, the modifier is "wrapped around" the modified function, placing its code in the location identified by the underscore character.</p></div>
<div class="paragraph"><p>To apply a modifier, you add its name to the function declaration. More than one modifier can be applied to a function; they are applied in the sequence they are declared, as a comma-separated list.</p></div>
<div class="paragraph"><p>Let&#8217;s rewrite our <code>destroy</code> function to use the <code>onlyOwner</code> modifier:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The function modifier&#8217;s name (<code>onlyOwner</code>) is after the keyword <code>public</code> and tells us that the <code>destroy</code> function is modified by the <code>onlyOwner</code> modifier. Essentially, you can read this as "Only the owner can destroy this contract." In practice, the resulting code is equivalent to "wrapping" the code from <code>onlyOwner</code> around <code>destroy</code>.</p></div>
<div class="paragraph"><p>Function modifiers are an extremely useful tool because they allow us to write preconditions for functions and apply them consistently, making the code easier to read and, as a result, easier to audit for security. They are most often used for access control, but they are quite versatile and can be used for a variety of other purposes.</p></div>
<div class="paragraph"><p>Inside a modifier, you can access all the values (variables and arguments) visible to the modified function. In this case, we can access the <code>owner</code> variable, which is declared within the contract. However, the inverse is not true: you cannot access any of the modifier&#8217;s variables inside the modified function.</p></div>
</div>
<div class="sect3">
<h4 id="_contract_inheritance">Contract Inheritance</h4>
<div class="paragraph"><p>Solidity&#8217;s <code>contract</code> object supports <em>inheritance</em>, which is a mechanism for extending a base contract with additional functionality. To use inheritance, specify a parent contract with the keyword <code>is</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>With this construct, the <code>Child</code> contract inherits all the methods, functionality, and variables of <code>Parent</code>. Solidity also supports multiple inheritance, which can be specified by comma-separated contract names after the keyword <code>is</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Contract inheritance allows us to write our contracts in such a way as to achieve modularity, extensibility, and reuse. We start with contracts that are simple and implement the most generic capabilities, then extend them by inheriting those capabilities in more specialized contracts.</p></div>
<div class="paragraph"><p>In our <code>Faucet</code> contract, we introduced the constructor and destructor, together with access control for an owner, assigned on construction. Those capabilities are quite generic: many contracts will have them. We can define them as generic contracts, then use inheritance to extend them to the <code>Faucet</code> contract.</p></div>
<div class="paragraph"><p>We start by defining a base contract <code>owned</code>, which has an <code>owner</code> variable, setting it in the contract&#8217;s constructor:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Next, we define a base contract <code>mortal</code>, which inherits <code>owned</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>As you can see, the <code>mortal</code> contract can use the <code>onlyOwner</code> function modifier, defined in <code>owned</code>. It indirectly also uses the <code>owner</code> address variable and the constructor defined in <code>owned</code>. Inheritance makes each contract simpler and focused on its specific functionality, allowing us to manage the details in a modular way.</p></div>
<div class="paragraph"><p>Now we can further extend the <code>owned</code> contract, inheriting its capabilities in <code>Faucet</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>By inheriting <code>mortal</code>, which in turn inherits <code>owned</code>, the <code>Faucet</code> contract now has the constructor and <code>destroy</code> functions, and a defined owner. The functionality is the same as when those functions were within <code>Faucet</code>, but now we can reuse those functions in other contracts without writing them again. Code reuse and modularity make our code cleaner, easier to read, and easier to audit.</p></div>
</div>
<div class="sect3">
<h4 id="_error_handling_assert_require_revert">Error Handling (assert, require, revert)</h4>
<div class="paragraph"><p>A contract call can terminate and return an error. Error handling in Solidity is handled by four functions: <code>assert</code>, <code>require</code>, <code>revert</code>, and <code>throw</code> (now deprecated).</p></div>
<div class="paragraph"><p>When a contract terminates with an error, all the state changes (changes to variables, balances, etc.) are reverted, all the way up the chain of contract calls if more than one contract was called. This ensures that transactions are <em>atomic</em>, meaning they either complete successfully or have no effect on state and are reverted entirely.</p></div>
<div class="paragraph"><p>The <code>assert</code> and <code>require</code> functions operate in the same way, evaluating a condition and stopping execution with an error if the condition is false. By convention, <code>assert</code> is used when the outcome is expected to be true, meaning that we use <code>assert</code> to test internal conditions. By comparison, <code>require</code> is used when testing inputs (such as function arguments or transaction fields), setting our expectations for those conditions.</p></div>
<div class="paragraph"><p>We&#8217;ve used <code>require</code> in our function modifier <code>onlyOwner</code>, to test that the message sender is the owner of the contract:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The <code>require</code> function acts as a <em>gate condition</em>, preventing execution of the rest of the function and producing an error if it is not satisfied.</p></div>
<div class="paragraph"><p>As of Solidity v0.4.22, <code>require</code> can also include a helpful text message that can be used to show the reason for the error. The error message is recorded in the transaction log. So, we can improve our code by adding an error message in our <code>require</code> function:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The <code>revert</code> and <code>throw</code> functions halt the execution of the contract and revert any state changes. The <code>throw</code> function is obsolete and will be removed in future versions of Solidity; you should use <code>revert</code> instead. The <code>revert</code> function can also take an error message as the only argument, which is recorded in the transaction log.</p></div>
<div class="paragraph"><p>Certain conditions in a contract will generate errors regardless of whether we explicitly check for them. For example, in our <code>Faucet</code> contract, we don&#8217;t check whether there is enough ether to satisfy a withdrawal request. That&#8217;s because the <code>transfer</code> function will fail with an error and revert the transaction if there is insufficient balance to make the transfer:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>However, it might be better to check explicitly and provide a clear error message on failure. We can do that by adding a <code>require</code> statement before the transfer:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Additional error-checking code like this will increase gas consumption slightly, but it offers better error reporting than if omitted. You will need to find the right balance between gas consumption and verbose error checking based on the expected use of your contract. In the case of a <code>Faucet</code> contract intended for a testnet, we&#8217;d probably err on the side of extra reporting even if it costs more gas. Perhaps for a mainnet contract we&#8217;d choose to be frugal with our gas usage instead.</p></div>
</div>
<div class="sect3">
<h4 id="solidity_events">Events</h4>
<div class="paragraph"><p>When a transaction completes (successfully or not), it produces a <em>transaction receipt</em>, as we will see in <a href="#evm_chapter">[evm_chapter]</a>. The transaction receipt contains <em>log</em> entries that provide information about the actions that occurred during the execution of the transaction. <em>Events</em> are the Solidity high-level objects that are used to construct these logs.</p></div>
<div class="paragraph"><p>Events are especially useful for light clients and DApp services, which can "watch" for specific events and report them to the user interface, or make a change in the state of the application to reflect an event in an underlying contract.</p></div>
<div class="paragraph"><p>Event objects take arguments that are serialized and recorded in the transaction logs, in the blockchain. You can supply the keyword <code>indexed</code> before an argument, to make the value part of an indexed table (hash table) that can be searched or filtered by an application.</p></div>
<div class="paragraph"><p>We have not added any events in our <code>Faucet</code> example so far, so let&#8217;s do that. We will add two events, one to log any withdrawals and one to log any deposits. We will call these events <code>Withdrawal</code> and <code>Deposit</code>, respectively. First, we define the events in the <code>Faucet</code> contract:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>We&#8217;ve chosen to make the addresses <code>indexed</code>, to allow searching and filtering in any user interface built to access our <code>Faucet</code>.</p></div>
<div class="paragraph"><p>Next, we use the <code>emit</code> keyword to incorporate the event data in the transaction logs:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The resulting <em>Faucet.sol</em> contract looks like <a href="#Faucet8_sol">[Faucet8_sol]</a>.</p></div>
<div class="exampleblock" id="Faucet8_sol">
<div class="title">Example 3. Faucet8.sol: Revised Faucet contract, with events</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="sect4">
<h5 id="_catching_events">Catching events</h5>
<div class="paragraph"><p>OK, so we&#8217;ve set up our contract to emit events. How do we see the results of a transaction and "catch" the events? The web3.js library provides a data structure that contains a transaction&#8217;s logs. Within those we can see the events generated by the transaction.</p></div>
<div class="paragraph"><p>Let&#8217;s use <code>truffle</code> to run a test transaction on the revised <code>Faucet</code> contract. Follow the instructions in <a href="#truffle">[truffle]</a> to set up a project directory and compile the <span class="keep-together"><code>Faucet</code></span> code. The source code can be found in <a href="https://github.com/ethereumbook/ethereumbook">the book&#8217;s GitHub repository</a> under <em>code/truffle/FaucetEvents</em>.</p></div>
<pre data-type="programlisting">
$ <strong>truffle develop</strong>
truffle(develop)> <strong>compile</strong>
truffle(develop)> <strong>migrate</strong>
Using network 'develop'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0xb77ceae7c3f5afb7fbe3a6c5974d352aa844f53f955ee7d707ef6f3f8e6b4e61
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying Faucet...
  ... 0xfa850d754314c3fb83f43ca1fa6ee20bc9652d891c00a2f63fd43ab5bfb0d781
  Faucet: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...

truffle(develop)> <strong>Faucet.deployed().then(i => {FaucetDeployed = i})</strong>
truffle(develop)> <strong>FaucetDeployed.send(web3.toWei(1, "ether")).then(res => \
                  { console.log(res.logs[0].event, res.logs[0].args) })</strong>
Deposit { from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 18, c: [ 10000 ] } }
truffle(develop)> <strong>FaucetDeployed.withdraw(web3.toWei(0.1, "ether")).then(res => \
                  { console.log(res.logs[0].event, res.logs[0].args) })</strong>
Withdrawal { to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 17, c: [ 1000 ] } }
</pre>
<div class="paragraph"><p>After deploying the contract using the <code>deployed</code> function, we execute two transactions. The first transaction is a deposit (using <code>send</code>), which emits a <code>Deposit</code> event in the transaction logs:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Deposit { from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 18, c: [ 10000 ] } }</code></pre>
</div></div>
<div class="paragraph"><p>Next, we use the <code>withdraw</code> function to make a withdrawal. This emits a <code>Withdrawal</code> event:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Withdrawal { to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 17, c: [ 1000 ] } }</code></pre>
</div></div>
<div class="paragraph"><p>To get these events, we looked at the <code>logs</code> array returned as a result (<code>res</code>) of the transactions. The first log entry (<code>logs[0]</code>) contains an event name in <code>logs[0].event</code> and the event arguments in <code>logs[0].args</code>. By showing these on the console, we can see the emitted event name and the event arguments.</p></div>
<div class="paragraph"><p>Events are a very useful mechanism, not only for intra-contract communication, but also for debugging during development.</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_calling_other_contracts_send_call_callcode_delegatecall">Calling Other Contracts (send, call, callcode, delegatecall)</h4>
<div class="paragraph"><p>Calling other contracts from within your contract is a very useful but potentially dangerous operation. We&#8217;ll examine the various ways you can achieve this and evaluate the risks of each method. In short, the risks arise from the fact that you may not know much about a contract you are calling into or that is calling into your contract. When writing smart contracts, you must keep in mind that while you may mostly expect to be dealing with EOAs, there is nothing to stop arbitrarily complex and perhaps malign contracts from calling into and being called by your code.</p></div>
<div class="sect4">
<h5 id="_creating_a_new_instance">Creating a new instance</h5>
<div class="paragraph"><p>The safest way to call another contract is if you create that other contract yourself. That way, you are certain of its interfaces and behavior. To do this, you can simply instantiate it, using the keyword <code>new</code>, as in other object-oriented languages. In Solidity, the keyword <code>new</code> will create the contract on the blockchain and return an object that you can use to reference it. Let&#8217;s say you want to create and call a <code>Faucet</code> contract from within another contract called <code>Token</code>:</p></div>
<div class="listingblock pagebreak-before">
<div class="content"></div></div>
<div class="paragraph"><p>This mechanism for contract construction ensures that you know the exact type of the contract and its interface. The contract <code>Faucet</code> must be defined within the scope of <code>Token</code>, which you can do with an <code>import</code> statement if the definition is in another file:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>You can optionally specify the <code>value</code> of ether transfer on creation, and pass arguments to the new contract&#8217;s constructor:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>You can also then call the <code>Faucet</code> functions. In this example, we call the <code>destroy</code> function of <code>Faucet</code> from within the <code>destroy</code> function of <code>Token</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Note that while you are the owner of the <code>Token</code> contract, the <code>Token</code> contract itself owns the new <code>Faucet</code> contract, so only the <code>Token</code> contract can destroy it.</p></div>
</div>
<div class="sect4">
<h5 id="_addressing_an_existing_instance">Addressing an existing instance</h5>
<div class="paragraph"><p>Another way you can call a contract is by casting the address of an existing instance of the contract. With this method, you apply a known interface to an existing instance. It is therefore critically important that you know, for sure, that the instance you are addressing is in fact of the type you assume. Let&#8217;s look at an example:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Here, we take an address provided as an argument to the constructor, <code>_f</code>, and we cast it to a <code>Faucet</code> object. This is much riskier than the previous mechanism, because we don&#8217;t know for sure whether that address actually is a <code>Faucet</code> object. When we call <code>withdraw</code>, we are assuming that it accepts the same arguments and executes the same code as our <code>Faucet</code> declaration, but we can&#8217;t be sure. For all we know, the <code>withdraw</code> function at this address could execute something completely different from what we expect, even if it is named the same. Using addresses passed as input and casting them into specific objects is therefore much more dangerous than creating the contract yourself.</p></div>
</div>
<div class="sect4">
<h5 id="_raw_call_delegatecall">Raw call, delegatecall</h5>
<div class="paragraph"><p>Solidity offers some even more "low-level" functions for calling other contracts. These correspond directly to EVM opcodes of the same name and allow us to construct a contract-to-contract call manually. As such, they represent the most flexible <em>and</em> the most dangerous mechanisms for calling other contracts.</p></div>
<div class="paragraph"><p>Here&#8217;s the same example, using a <code>call</code> method:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>As you can see, this type of <code>call</code> is a <em>blind</em> call into a function, very much like constructing a raw transaction, only from within a contract&#8217;s context. It can expose your contract to a number of security risks, most importantly <em>reentrancy</em>, which we will discuss in more detail in <a href="#reentrancy_security">[reentrancy_security]</a>. The <code>call</code> function will return <code>false</code> if there is a problem, so you can evaluate the return value for error handling:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Another variant of <code>call</code> is <code>delegatecall</code>, which replaced the more dangerous <code>callcode</code>. The <code><span class="keep-together">callcode</span></code> method will be deprecated soon, so it should not be used.</p></div>
<div class="paragraph"><p>As mentioned in <a href="#solidity_address_object">[solidity_address_object]</a>, a <code>delegatecall</code> is different from a <code>call</code> in that the <code>msg</code> context does not change. For example, whereas a <code>call</code> changes the value of <code>msg.sender</code> to be the calling contract, a <code>delegatecall</code> keeps the same <code>msg.sender</code> as in the calling contract. Essentially, <code>delegatecall</code> runs the code of another contract inside the context of the execution of the current contract. It is most often used to invoke code from a library. It also allows you to draw on the pattern of using library functions stored elsewhere, but have that code work with the storage data of your contract.</p></div>
<div class="paragraph"><p>The <code>delegate</code> call should be used with great caution. It can have some unexpected effects, especially if the contract you call was not designed as a library.</p></div>
<div class="paragraph"><p>Let&#8217;s use an example contract to demonstrate the various call semantics used by <code>call</code> and <code>delegatecall</code> for calling libraries and contracts. In <a href="#call_examples_code">[call_examples_code]</a>, we use an event to log the details of each call and see how the calling context changes depending on the call type.</p></div>
<div class="exampleblock" id="call_examples_code">
<div class="title">Example 4. CallExamples.sol: An example of different call semantics</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>As you can see in this example, our main contract is <code>caller</code>, which calls a library <code>calledLibrary</code> and a contract <code>calledContract</code>. Both the called library and the contract have identical <code>calledFunction</code> functions, which emit an event <code>calledEvent</code>. The event <code>calledEvent</code> logs three pieces of data: <code>msg.sender</code>, <code>tx.origin</code>, and <code>this</code>. Each time <code>calledFunction</code> is called it may have a different execution context (with different values for potentially all the context variables), depending on whether it is called directly or through <code>delegatecall</code>.</p></div>
<div class="paragraph"><p>In <code>caller</code>, we first call the contract and library directly, by invoking <code>calledFunction</code> in each. Then, we explicitly use the low-level functions <code>call</code> and <code>delegatecall</code> to call <code>calledContract.calledFunction</code>. This way we can see how the various calling mechanisms behave.</p></div>
<div class="paragraph"><p>Let&#8217;s run this in a Truffle development environment and capture the events, to see how it looks:</p></div>
<pre data-type="programlisting">
truffle(develop)> <strong>migrate</strong>
Using network 'develop'.
[...]
Saving artifacts...
truffle(develop)> <strong>web3.eth.accounts[0]</strong>
'0x627306090abab3a6e1400e9345bc60c78a8bef57'
truffle(develop)> <strong>caller.address</strong>
'0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f'
truffle(develop)> <strong>calledContract.address</strong>
'0x345ca3e014aaf5dca488057592ee47305d9b3e10'
truffle(develop)> <strong>calledLibrary.address</strong>
'0xf25186b5081ff5ce73482ad761db0eb0d25abfbf'
truffle(develop)> <strong>caller.deployed().then( i => { callerDeployed = i })</strong>

truffle(develop)> <strong>callerDeployed.make_calls(calledContract.address).then(res => \
                  { res.logs.forEach( log => { console.log(log.args) })})</strong>
{ sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10' }
{ sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f' }
{ sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10' }
{ sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f' }
</pre>
<div class="paragraph"><p>Let&#8217;s see what happened here. We called the <code>make_calls</code> function and passed the address of <code>calledContract</code>, then caught the four events emitted by each of the different calls. Let&#8217;s look at the <code>make_calls</code> function and walk through each step.</p></div>
<div class="paragraph"><p>The first call is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>_calledContract.calledFunction();</code></pre>
</div></div>
<div class="paragraph"><p>Here, we&#8217;re calling <code>calledContract.calledFunction</code> directly, using the high-level ABI for <code>calledFunction</code>. The event emitted is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10'</code></pre>
</div></div>
<div class="paragraph"><p>As you can see, <code>msg.sender</code> is the address of the <code>caller</code> contract. The <code>tx.origin</code> is the address of our account, <code>web3.eth.accounts[0]</code>, that sent the transaction to <code>caller</code>. The event was emitted by <code>calledContract</code>, as we can see from the last argument in the event.</p></div>
<div class="paragraph"><p>The next call in <code>make_calls</code> is to the library:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>calledLibrary.calledFunction();</code></pre>
</div></div>
<div class="paragraph"><p>It looks identical to how we called the contract, but behaves very differently. Let&#8217;s look at the second event emitted:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f'</code></pre>
</div></div>
<div class="paragraph"><p>This time, the <code>msg.sender</code> is not the address of <code>caller</code>. Instead, it is the address of our account, and is the same as the transaction origin. That&#8217;s because when you call a library, the call is always <code>delegatecall</code> and runs within the context of the caller. So, when the <code>calledLibrary</code> code was running, it inherited the execution context of <code>caller</code>, as if its code was running inside <code>caller</code>. The variable <code>this</code> (shown as <code>from</code> in the event emitted) is the address of <code>caller</code>, even though it is accessed from within <span class="keep-together"><code>calledLibrary</code></span>.</p></div>
<div class="paragraph"><p>The next two calls, using the low-level <code>call</code> and <code>delegatecall</code>, verify our expectations, emitting events that mirror what we just saw.</p></div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gas_sec">Gas Considerations</h3>
<div class="paragraph"><p>Gas, described in more in detail in <a href="#gas">[gas]</a>, is an incredibly important consideration in smart contract programming. Gas is a resource constraining the maximum amount of computation that Ethereum will allow a transaction to consume. If the gas limit is exceeded during computation, the following series of events occurs:</p></div>
<div class="ulist"><ul>
<li>
<p>
An "out of gas" exception is thrown.
</p>
</li>
<li>
<p>
The state of the contract prior to execution is restored (reverted).
</p>
</li>
<li>
<p>
All ether used to pay for the gas is taken as a transaction fee; it is <em>not</em> refunded.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Because gas is paid by the user who initiates the transaction, users are discouraged from calling functions that have a high gas cost. It is thus in the programmer&#8217;s best interest to minimize the gas cost of a contract&#8217;s functions. To this end, there are certain practices that are recommended when constructing smart contracts, so as to minimize the gas cost of a function call.</p></div>
<div class="sect3">
<h4 id="_avoid_dynamically_sized_arrays">Avoid Dynamically Sized Arrays</h4>
<div class="paragraph"><p>Any loop through a dynamically sized array where a function performs operations on each element or searches for a particular element introduces the risk of using too much gas. Indeed, the contract may run out of gas before finding the desired result, or before acting on every element, thus wasting time and ether without giving any result at all.</p></div>
</div>
<div class="sect3">
<h4 id="_avoid_calls_to_other_contracts">Avoid Calls to Other Contracts</h4>
<div class="paragraph"><p>Calling other contracts, especially when the gas cost of their functions is not known, introduces the risk of running out of gas. Avoid using libraries that are not well tested and broadly used. The less scrutiny a library has received from other programmers, the greater the risk of using it.</p></div>
</div>
<div class="sect3">
<h4 id="_estimating_gas_cost">Estimating Gas Cost</h4>
<div class="paragraph"><p>If you need to estimate the gas necessary to execute a certain method of a contract considering its arguments, you could use the following procedure:</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #0000FF">var</span></span> contract <span style="color: #990000">=</span> web3<span style="color: #990000">.</span>eth<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">contract</span></span><span style="color: #990000">(</span>abi<span style="color: #990000">).</span><span style="font-weight: bold"><span style="color: #000000">at</span></span><span style="color: #990000">(</span>address<span style="color: #990000">);</span>
<span style="font-weight: bold"><span style="color: #0000FF">var</span></span> gasEstimate <span style="color: #990000">=</span> contract<span style="color: #990000">.</span>myAweSomeMethod<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">estimateGas</span></span><span style="color: #990000">(</span>arg1<span style="color: #990000">,</span> arg2<span style="color: #990000">,</span> <span style="color: #FF0000">{</span>from<span style="color: #990000">:</span> account<span style="color: #FF0000">}</span><span style="color: #990000">);</span></tt></pre></div></div>
<div class="paragraph"><p><code>gasEstimate</code> will tell you the number of gas units needed for its execution. It is an estimate because of the Turing completeness of the EVM&#x2014;it is relatively trivial to create a function that will take vastly different amounts of gas to execute different calls. Even production code can change execution paths in subtle ways, resulting in hugely different gas costs from one call to the next. However, most functions are sensible and <code>estimateGas</code> will give a good estimate most of the time.</p></div>
<div class="paragraph"><p>To obtain the gas price from the network you can use:</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #0000FF">var</span></span> gasPrice <span style="color: #990000">=</span> web3<span style="color: #990000">.</span>eth<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">getGasPrice</span></span><span style="color: #990000">();</span></tt></pre></div></div>
<div class="paragraph"><p>And from there you can estimate the gas cost:</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #0000FF">var</span></span> gasCostInEther <span style="color: #990000">=</span> web3<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">fromWei</span></span><span style="color: #990000">((</span>gasEstimate <span style="color: #990000">*</span> gasPrice<span style="color: #990000">),</span> <span style="color: #FF0000">'ether'</span><span style="color: #990000">);</span></tt></pre></div></div>
<div class="paragraph"><p>Let&#8217;s apply our gas estimation functions to estimating the gas cost of our <code>Faucet</code> example, using the code <a href="http://bit.ly/2zf0SIO">from the book&#8217;s repository</a>.</p></div>
<div class="paragraph"><p>Start Truffle in development mode and execute the JavaScript file in <a href="#estimateGas_function">[estimateGas_function]</a>, <em>gas_estimates.js</em>.</p></div>
<div class="exampleblock" id="estimateGas_function">
<div class="title">Example 5. gas_estimates.js: Using the estimateGas function</div>
<div class="content">
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #0000FF">var</span></span> FaucetContract <span style="color: #990000">=</span> artifacts<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">require</span></span><span style="color: #990000">(</span><span style="color: #FF0000">"./Faucet.sol"</span><span style="color: #990000">);</span>

FaucetContract<span style="color: #990000">.</span>web3<span style="color: #990000">.</span>eth<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">getGasPrice</span></span><span style="color: #990000">(</span><span style="font-weight: bold"><span style="color: #0000FF">function</span></span><span style="color: #990000">(</span>error<span style="color: #990000">,</span> result<span style="color: #990000">)</span> <span style="color: #FF0000">{</span>
    <span style="font-weight: bold"><span style="color: #0000FF">var</span></span> gasPrice <span style="color: #990000">=</span> <span style="font-weight: bold"><span style="color: #000000">Number</span></span><span style="color: #990000">(</span>result<span style="color: #990000">);</span>
    console<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">log</span></span><span style="color: #990000">(</span><span style="color: #FF0000">"Gas Price is "</span> <span style="color: #990000">+</span> gasPrice <span style="color: #990000">+</span> <span style="color: #FF0000">" wei"</span><span style="color: #990000">);</span> <span style="font-style: italic"><span style="color: #9A1900">// "10000000000000"</span></span>

    <span style="font-style: italic"><span style="color: #9A1900">// Get the contract instance</span></span>
    FaucetContract<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">deployed</span></span><span style="color: #990000">().</span><span style="font-weight: bold"><span style="color: #000000">then</span></span><span style="color: #990000">(</span><span style="font-weight: bold"><span style="color: #0000FF">function</span></span><span style="color: #990000">(</span>FaucetContractInstance<span style="color: #990000">)</span> <span style="color: #FF0000">{</span>

                <span style="font-style: italic"><span style="color: #9A1900">// Use the keyword 'estimateGas' after the function name to get the gas</span></span>
                <span style="font-style: italic"><span style="color: #9A1900">// estimation for this particular function (aprove)</span></span>
                FaucetContractInstance<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">send</span></span><span style="color: #990000">(</span>web3<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">toWei</span></span><span style="color: #990000">(</span><span style="color: #993399">1</span><span style="color: #990000">,</span> <span style="color: #FF0000">"ether"</span><span style="color: #990000">));</span>
        <span style="font-weight: bold"><span style="color: #0000FF">return</span></span> FaucetContractInstance<span style="color: #990000">.</span>withdraw<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">estimateGas</span></span><span style="color: #990000">(</span>web3<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">toWei</span></span><span style="color: #990000">(</span><span style="color: #993399">0.1</span><span style="color: #990000">,</span> <span style="color: #FF0000">"ether"</span><span style="color: #990000">));</span>

    <span style="color: #FF0000">}</span><span style="color: #990000">).</span><span style="font-weight: bold"><span style="color: #000000">then</span></span><span style="color: #990000">(</span><span style="font-weight: bold"><span style="color: #0000FF">function</span></span><span style="color: #990000">(</span>result<span style="color: #990000">)</span> <span style="color: #FF0000">{</span>
        <span style="font-weight: bold"><span style="color: #0000FF">var</span></span> gas <span style="color: #990000">=</span> <span style="font-weight: bold"><span style="color: #000000">Number</span></span><span style="color: #990000">(</span>result<span style="color: #990000">);</span>

        console<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">log</span></span><span style="color: #990000">(</span><span style="color: #FF0000">"gas estimation = "</span> <span style="color: #990000">+</span> gas <span style="color: #990000">+</span> <span style="color: #FF0000">" units"</span><span style="color: #990000">);</span>
        console<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">log</span></span><span style="color: #990000">(</span><span style="color: #FF0000">"gas cost estimation = "</span> <span style="color: #990000">+</span> <span style="color: #990000">(</span>gas <span style="color: #990000">*</span> gasPrice<span style="color: #990000">)</span> <span style="color: #990000">+</span> <span style="color: #FF0000">" wei"</span><span style="color: #990000">);</span>
        console<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">log</span></span><span style="color: #990000">(</span><span style="color: #FF0000">"gas cost estimation = "</span> <span style="color: #990000">+</span>
                FaucetContract<span style="color: #990000">.</span>web3<span style="color: #990000">.</span><span style="font-weight: bold"><span style="color: #000000">fromWei</span></span><span style="color: #990000">((</span>gas <span style="color: #990000">*</span> gasPrice<span style="color: #990000">),</span> <span style="color: #FF0000">'ether'</span><span style="color: #990000">)</span> <span style="color: #990000">+</span> <span style="color: #FF0000">" ether"</span><span style="color: #990000">);</span>
    <span style="color: #FF0000">}</span><span style="color: #990000">);</span>
<span style="color: #FF0000">}</span><span style="color: #990000">);</span></tt></pre></div></div>
</div></div>
<div class="paragraph pagebreak-after"><p>Here&#8217;s how that looks in the Truffle development console:</p></div>
<pre data-type="programlisting">
$ <strong>truffle develop</strong>

truffle(develop)> <strong>exec gas_estimates.js</strong>
Using network 'develop'.

Gas Price is 20000000000 wei
gas estimation = 31397 units
gas cost estimation = 627940000000000 wei
gas cost estimation = 0.00062794 ether
</pre>
<div class="paragraph"><p>It is recommended that you evaluate the gas cost of functions as part of your development workflow, to avoid any surprises when deploying contracts to the mainnet.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusions">Conclusions</h3>
<div class="paragraph"><p>In this chapter we started working with smart contracts in detail and explored the Solidity contract programming language. We took a simple example contract, <em>Faucet.sol</em>, and gradually improved it and made it more complex, using it to explore various aspects of the Solidity language. In <a href="#vyper_chap">[vyper_chap]</a> we will work with Vyper, another contract-oriented programming language. We will compare Vyper to Solidity, showing some of the differences in the design of these two languages and deepening our understanding of smart contract programming.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2018-11-18 00:22:44 JST
</div>
</div>
</body>
</html>
